---
title: 'Caching'
description: 'Faster DX for advanced TeX blocks'
icon: 'gear'
---

SvelTeX uses caching to reduce build times, with special focus on HMR.

## General approach

### Setup

First, Sveltex decides what directory to use for its cache. Usually, this will
be `node_modules/.cache/sveltex-preprocess`. It will then populate it with a
JSON file `cache.json`, as detailed below.

<Accordion
    title="Fixture for examples"
    icon="circle-info"
>
To contextualize our examples below, we understand the following fixture to
apply:
<CodeGroup>

```js sveltex.config.js
import { sveltex } from 'sveltex-preprocess';

export const sveltexPreprocessor = await sveltex(
    'none',
    'none',
    'none',
    'local',
);

await sveltexPreprocessor.configure({
    advancedTex: {
        components: {
            TeX: {},
            TikZ: {
                documentClass: '\\documentclass[tikz]{standalone}',
            },
        },
    },
});
```

```js svelte.config.js
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';
import { sveltexPreprocessor } from './sveltex.config.js';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: [sveltexPreprocessor, vitePreprocess()],
    extensions: [
        '.svelte',
        ...sveltexPreprocessor.configuration.general.extensions,
    ],
    kit: {
        adapter: adapter(),
    },
};

export default config;
```

</CodeGroup>
</Accordion>

### Adding and updating a TeX component

<Steps>
<Step title="Initial state">
    If Sveltex was set up with the `'local'` advanced TeX backend selected, we have
    the following initial state, even if no TeX components are used anywhere:
    <CodeGroup>
        ```json cache.json
        {
            // Record to keep track of hashes of files.
            // - key = filepath
            // - val = hash of file that key points to
            "hashes": {},
            // Record to keep track of the hashes of the "source files" of given
            // PDF and SVG files. By source file we mean, in the case of a
            // PDF/DVI, the TeX file that was used to generate it, and, in the
            // case of a SVG file, the PDF/DVI file that was used to generate it.
            // - key = filepath
            // - val = hash of source file of file that key points to
            "sources": {},
            // Array containing filepaths of files that are "up for deletion".
            // New filepaths are pushed to the end, and once the array reaches a
            // certain size, the first filepath in the array is deleted,
            // alongside the file it points to.
            "__delete": []
        }
        ```

        ```gitignore File tree
        .
        ├── node_modules/
        │   └── .cache/
        │       └── sveltex-preprocess/
        │           └── cache.json
        └── static/
        ```
    </CodeGroup>

</Step>
<Step title="Add TeX component">
    Now, if a file `+page.sveltex` contains an TeX component `<TeX>...</TeX>` with name
    `'TeX'` and is built, the `cache.json` file will be updated as follows:

    <CodeGroup>

    ```json cache.json
    {
        "hashes": {
            "TeX/[ref].tex": "[HASH_TEX_1]",
            "TeX/[ref].pdf": "[HASH_PDF_1]",
            "TeX/[ref].svg": "[HASH_SVG_1]"
        },
        "sources": {
            "TeX/[ref].pdf": "[HASH_TEX_1]",
            "TeX/[ref].svg": "[HASH_PDF_1]"
        },
        "__delete": []
    }
    ```

    ```gitignore File tree
    .
    ├── node_modules/
    │   └── .cache/
    │       └── sveltex-preprocess/
    │           ├── cache.json
    │           └── TeX/
    │               ├── [ref].tex
    │               ├── [ref].pdf
    │               └── [ref].(aux|log|...)
    └── static/
        └── sveltex/
            └── TeX/
                └── [ref].svg
    ```

    </CodeGroup>

</Step>
<Step title="Update TeX component content">
    Now, suppose we change some code inside `<TeX>...</TeX>` in `+page.sveltex`,
    so that the hash of the new content is `[HASH_TEX_2]`. What happens then is:

    1.  If `HASH_TEX_2 === HASH_TEX_1`, *return now*. Otherwise, overwrite
        `TeX/[ref].tex` with new content.
    2.  Update `cache.json`:
        -   `hashes['TeX/[ref].tex'] = HASH_TEX_2`.
    3.  Compile updated `TeX/[ref].tex`.
    4.  If compilation failed, *return now*. Otherwise, compute hash
        `HASH_PDF_2` of new `TeX/[ref].pdf`.
    5.  If `HASH_PDF_2 === HASH_PDF_1`, *return now*. Otherwise, update
        `cache.json`:
        -   `hashes['TeX/[ref].pdf'] = HASH_PDF_2`
        -   `sources['TeX/[ref].pdf'] = HASH_TEX_2`
    7.

    1.  Does `node_modules/.cache/sveltex-preprocess/TeX/hash_new.tex` exist?
        -   `true`: noop.
        -   `false`: create it.
    2.  Does `node_modules/.cache/sveltex-preprocess/TeX/hash_new.pdf` exist?
        -   `true`: noop.
        -   `false`: Compile `hash_new.tex` → `hash_new.pdf`
    3.  `static/sveltex/TeX/ref_or_hash_new.svg` exists?
        -   `true`: Get value from `cache.json` at key `static/sveltex/TeX/ref_or_hash_new.svg`. In line with the previous step, this value would be `'TeX/hash.pdf'`. Now: `'TeX/hash.pdf' === 'TeX/hash_new.pdf'`?:
            -   `true`: noop.
            -   `false`:
                1.  Convert `hash_new.pdf` → `ref_or_hash_new.svg`
                2.  Push `'hash.pdf'`
        -   `false`: Convert `hash_new.pdf` → `hash_new.svg`

    <AccordionGroup>
        <Accordion
            title="node_modules/.cache/sveltex-preprocess/cache.json"
        >
        ```json
        {
            "TeX/hash_new.svg": "TeX/hash_new.pdf",
            "__delete": ["TeX/hash1.pdf"]
        }
        ```
        </Accordion>
        <Accordion
            title="node_modules/.cache/sveltex-preprocess/"
        >
        ```gitignore
        cache.json
        TeX/hash1.tex
        TeX/hash1.pdf
        # ...auxiliary files (.aux, .log, etc)
        ```
        </Accordion>
        <Accordion
            title="static/sveltex/"
        >
        ```gitignore
        TeX/hash1.svg
        ```
        </Accordion>
    </AccordionGroup>

</Step>
</Steps>

Suppose another (or the same) `+page.sveltex` file contains another TeX
component, but this time with a `ref` attribute set:
`<TeX ref="something">...</TeX>`. Then, at build time, the `cache.json` file
will be updated as follows:

<AccordionGroup>
<Accordion
    title="node_modules/.cache/sveltex-preprocess/cache.json"
>
```json
{
    "TeX/hash1.svg": "TeX/hash1.pdf",
    "TeX/something.svg": "<hash2>.pdf",
    "TikZ/something.svg": "<hash3>.pdf",
    "TikZ/hash4.svg": "<hash4>.dvi",
    "__delete": []
}
```
</Accordion>
<Accordion
    title="node_modules/.cache/sveltex-preprocess/"
>
```gitignore
cache.json
TeX/hash1.tex
TeX/hash1.pdf
TeX/<hash2>.tex
TeX/<hash2>.pdf
# ...auxiliary files (.aux, .log, etc)
```
</Accordion>
<Accordion
    title="static/sveltex/"
>
```gitignore
TeX/hash1.svg
TeX/something.svg
```
</Accordion>
</AccordionGroup>

Meanwhile, the cache directory will be populated as follows:

And the `static` directory:

```gitignore
sveltex/TeX/hash1.svg
sveltex/TeX/something.svg
```

### Miscellaneous

#### Why not use Vite's HMR API?

Despite the popularity of SvelteKit (which uses Vite), Svelte can also be used
without Vite, so we don't want to use Vite-specific API if we can avoid it.
